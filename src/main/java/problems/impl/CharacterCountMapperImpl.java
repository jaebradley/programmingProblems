package problems.impl;

import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import problems.interfaces.CharacterCountMapper;

/**
 * Inspired by this HackerRank problem: https://www.hackerrank.com/challenges/sherlock-and-valid-string
 *
 * A "valid" string is a string  such that for all distinct characters in String S each such character occurs the same number of times in S.
 * For example, aabb is a valid string because the frequency of both characters a and b is , whereas aabbc is not a valid string because the frequency of characters a, b, and c is not the same.
 * Watson gives a string  to Sherlock and asks him to remove some characters from the string such that the new string is a "valid" string.
 * Sherlock wants to know from you if it's possible to be done with less than or equal to one removal.
 */

public class CharacterCountMapperImpl implements CharacterCountMapper {

  /**
   * Calculates the count of each character in the given input String
   * @param value String from which the map of characters and their counts is constructed from
   * @return a Map of character keys and their counts for the given input String
   */
  @Override
  public Map<Character, Long> mapCharacterCount(final String value) {
    if (null == value) {
      throw new IllegalArgumentException("input string cannot be null");
    }
    final Map<Character, Long> characterCountMap = new HashMap<>();
    for (char c : value.toCharArray()) {
      final Long keyValue = characterCountMap.get(c);
      long updatedKeyValue = keyValue == null ? 1L : keyValue + 1;
      characterCountMap.put(c, updatedKeyValue);
    }
    return characterCountMap;
  }

  /**
   * Based on this HackerRank problem: https://www.hackerrank.com/challenges/sherlock-and-valid-string a valid String
   * is a string such that for all distinct characters in String S each such character occurs the same number of times in S.
   * @param value String
   * @return boolean that indicates if the inputted String is valid or not
   */
  @Override
  public boolean isValidString(final String value) {
    if (null == value) {
      throw new IllegalArgumentException("input string cannot be null");
    }
    final Map<Character, Long> characterCountMap = mapCharacterCount(value);
    return new HashSet<>(characterCountMap.values()).size() <= 1;
  }

  /**
   * Returns a boolean based on whether or not a "valid" String can be generated by the removal of a single character
   * @param value String
   * @return boolean that indicates if removing one character from the input String creates a "valid" String
   */

  @Override
  public boolean isAlmostValidStringByRemoval(final String value) {
    if (null == value) {
      throw new IllegalArgumentException("input string cannot be null");
    }
    final Map<Character, Long> characterCountMap = mapCharacterCount(value);
    final Set<Long> distinctCounts = new HashSet<>(characterCountMap.values());
    final long minValue = Collections.min(distinctCounts);

    if (distinctCounts.size() == 0) {
      return false;
    }

    long minValueCount = 0;
    for (final long characterCount : characterCountMap.values()) {
      if (characterCount == minValue) {
        minValueCount++;
      }
    }

    final long absoluteCountsDifference = Math.abs(Collections.max(distinctCounts)) - Math.abs(Collections.min(distinctCounts));
    final boolean isOneMaxValueWithOneUnitDifference = absoluteCountsDifference == 1 && minValueCount == characterCountMap.values().size() - 1;
    final boolean isOneMinValue = minValue == 1 && minValueCount == 1;
    return distinctCounts.size() == 2 && (isOneMaxValueWithOneUnitDifference || isOneMinValue);
  }

  /**
   * Returns a boolean that indicates if the input String a "valid" String or is one character removal away from being a "valid" String
   * @param value String
   * @return boolean
   */
  @Override
  public boolean isAtLeastAlmostValidStringByRemoval(final String value) {
    return isAlmostValidStringByRemoval(value) || isValidString(value);
  }
}
